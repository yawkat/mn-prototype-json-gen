package io.micronaut.jsongen.bean;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.squareup.javapoet.*;
import io.micronaut.inject.ast.ClassElement;
import io.micronaut.inject.ast.ConstructorElement;
import io.micronaut.inject.ast.PrimitiveElement;
import io.micronaut.jsongen.JsonParseException;
import io.micronaut.jsongen.Serializer;
import io.micronaut.jsongen.generator.PoetUtil;
import io.micronaut.jsongen.generator.SerializerLinker;
import io.micronaut.jsongen.generator.SerializerSymbol;

import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

import static io.micronaut.jsongen.generator.Names.DECODER;
import static io.micronaut.jsongen.generator.Names.ENCODER;

public class BeanSerializerGenerator {
    private static final String VALUE = "value";
    private static final String INSTANCE = "INSTANCE";

    private final SerializerLinker linker;

    private final ClassElement clazz;
    private final BeanDefinition definition;

    /**
     * Qualified name of the {@link Serializer} implementation generated by this class
     */
    private final ClassName qualifiedName;

    /**
     * Map of sanitized property names. <br>
     * Key: property name ({@link BeanDefinition.Property#name})
     * Value: a valid java identifier
     */
    private final Map<String, String> sanitizedPropertyNames;

    public BeanSerializerGenerator(SerializerLinker linker, ClassElement clazz) {
        this.linker = linker;
        this.clazz = clazz;
        this.definition = BeanIntrospector.introspect(clazz);

        String name = clazz.getSimpleName() + "$Serializer";
        qualifiedName = ClassName.get(clazz.getPackageName(), name);

        sanitizedPropertyNames = new HashMap<>();
        for (BeanDefinition.Property prop : definition.props.values()) {
            // prefix with $ so we get no collision with other variables we use in normal control flow
            String sane = "$" + prop.name.replaceAll("[^a-z0-9]", "_");
            // avoid collisions
            while (sanitizedPropertyNames.containsValue(sane)) {
                sane += "_";
            }
            sanitizedPropertyNames.put(prop.name, sane);
        }
    }

    public ClassName getQualifiedName() {
        return qualifiedName;
    }

    public JavaFile generate() {
        TypeSpec serializer = TypeSpec.classBuilder(qualifiedName.simpleName())
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addSuperinterface(ParameterizedTypeName.get(ClassName.get(Serializer.class), PoetUtil.toTypeName(clazz)))
                .addField(FieldSpec.builder(qualifiedName, INSTANCE)
                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                        .initializer("new $T()", qualifiedName)
                        .build())
                .addMethod(MethodSpec.constructorBuilder()
                        .addModifiers(Modifier.PRIVATE)
                        .build())
                .addMethod(MethodSpec.methodBuilder("serialize")
                        .addAnnotation(Override.class)
                        .addModifiers(Modifier.PUBLIC)
                        .addParameter(JsonGenerator.class, ENCODER)
                        .addParameter(PoetUtil.toTypeName(clazz), VALUE)
                        .addException(IOException.class)
                        .addCode(generateSerialize())
                        .build())
                .addMethod(MethodSpec.methodBuilder("deserialize")
                        .addAnnotation(Override.class)
                        .addModifiers(Modifier.PUBLIC)
                        .addParameter(JsonParser.class, DECODER)
                        .returns(PoetUtil.toTypeName(clazz)) // todo: specialize for generics?
                        .addException(IOException.class)
                        .addCode(generateDeserialize())
                        .build())
                .build();
        return JavaFile.builder(clazz.getPackageName(), serializer).build();
    }

    private CodeBlock generateSerialize() {
        CodeBlock.Builder serialize = CodeBlock.builder();
        // passing the value to writeStartObject helps with debugging, but will not affect functionality
        serialize.addStatement("$N.writeStartObject($N)", ENCODER, VALUE);
        for (BeanDefinition.Property prop : definition.props.values()) {
            serialize.addStatement("$N.writeFieldName($S)", ENCODER, prop.name);
            serialize.add(serializeBeanProperty(prop));
        }
        serialize.addStatement("$N.writeEndObject()", ENCODER);
        return serialize.build();
    }

    private CodeBlock serializeBeanProperty(BeanDefinition.Property property) {
        ClassElement type;
        CodeBlock readExpression;
        if (property.getter != null) {
            type = property.getter.getGenericReturnType();
            readExpression = CodeBlock.of("$N.$N()", VALUE, property.getter.getName());
        } else if (property.isGetter != null) {
            type = property.isGetter.getGenericReturnType();
            readExpression = CodeBlock.of("$N.$N()", VALUE, property.isGetter.getName());
        } else if (property.field != null) {
            type = property.field.getGenericType();
            readExpression = CodeBlock.of("$N.$N", VALUE, property.field.getName());
        } else {
            throw new UnsupportedOperationException(); // TODO
        }
        return linker.findSymbolForSerialize(type).serialize(type, readExpression);
    }

    private CodeBlock generateDeserialize() {
        CodeBlock.Builder deserialize = CodeBlock.builder();
        deserialize.add("if ($N.getCurrentToken() != $T.START_OBJECT) throw $T.from($N, \"Unexpected token \" + $N.getCurrentToken() + \", expected START_OBJECT\");\n",
                DECODER, JsonToken.class, JsonParseException.class, DECODER, DECODER);

        // types used for deserialization
        Map<BeanDefinition.Property, ClassElement> deserializeTypes = definition.props.values().stream().collect(Collectors.toMap(prop -> prop, prop -> {
            if (prop.setter != null) {
                return prop.setter.getParameters()[0].getGenericType(); // TODO: bounds checks
            } else if (prop.field != null) {
                return prop.field.getGenericType();
            } else {
                throw new UnsupportedOperationException(); // TODO: we can still generate serializer code
            }
        }));
        // create a local variable for each property
        for (BeanDefinition.Property prop : definition.props.values()) {
            deserialize.addStatement("$T $N = $L", PoetUtil.toTypeName(deserializeTypes.get(prop)), sanitizedPropertyNames.get(prop.name), getDefaultValueExpression(deserializeTypes.get(prop)));
        }

        // main parse loop
        deserialize.beginControlFlow("while (true)");
        deserialize.addStatement("$T token = $N.nextToken()", JsonToken.class, DECODER);
        deserialize.add("if (token == $T.END_OBJECT) break;\n", JsonToken.class);
        deserialize.add("if (token != $T.FIELD_NAME) throw $T.from($N, \"Unexpected token \" + token + \", expected END_OBJECT or FIELD_NAME\");\n",
                JsonToken.class, JsonParseException.class, DECODER);
        deserialize.addStatement("String fieldName = $N.getCurrentName()", DECODER);
        deserialize.addStatement("$N.nextToken()", DECODER);
        deserialize.beginControlFlow("switch (fieldName)", DECODER);
        for (BeanDefinition.Property prop : definition.props.values()) {
            deserialize.beginControlFlow("case $S:", prop.name);
            // TODO: check for duplicate field
            ClassElement propType = deserializeTypes.get(prop);
            SerializerSymbol.DeserializationCode deserializationCode = linker.findSymbolForDeserialize(propType).deserialize(propType);
            deserialize.add(deserializationCode.getStatements());
            deserialize.addStatement("$N = $L", sanitizedPropertyNames.get(prop.name), deserializationCode.getResultExpression());
            deserialize.addStatement("break");
            deserialize.endControlFlow();
        }
        deserialize.endControlFlow();
        deserialize.endControlFlow();

        // todo: check for missing fields

        // assemble the result object

        // todo: @JsonCreator
        if (definition.defaultConstructor instanceof ConstructorElement) {
            deserialize.addStatement("$T result = new $T()", PoetUtil.toTypeName(clazz), PoetUtil.toTypeName(clazz));
        } else if (definition.defaultConstructor.isStatic()) {
            // TODO edge cases?
            deserialize.addStatement("$T result = $T.$N()", PoetUtil.toTypeName(clazz), PoetUtil.toTypeName(definition.defaultConstructor.getDeclaringType()), definition.defaultConstructor.getName());
        } else {
            throw new UnsupportedOperationException("Creator must be static method or constructor");
        }
        for (BeanDefinition.Property prop : definition.props.values()) {
            String localVariable = sanitizedPropertyNames.get(prop.name);
            if (prop.setter != null) {
                deserialize.addStatement("result.$N($N)", prop.setter.getName(), localVariable);
            } else if (prop.field != null) {
                deserialize.addStatement("result.$N = $N", prop.field.getName(), localVariable);
            } else {
                // TODO: fail gracefully, can still serialize
                throw new UnsupportedOperationException("Cannot set property " + prop.name);
            }
        }
        deserialize.addStatement("return result");

        return deserialize.build();
    }

    private static String getDefaultValueExpression(ClassElement clazz) {
        if (clazz.isPrimitive() && !clazz.isArray()) {
            if (clazz.equals(PrimitiveElement.VOID)) {
                throw new UnsupportedOperationException("void cannot be assigned");
            } else if (clazz.equals(PrimitiveElement.BOOLEAN)) {
                return "false";
            } else {
                return "0";
            }
        } else {
            return "null";
        }
    }

}
